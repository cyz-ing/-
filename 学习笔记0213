1.关于算法：algorithm（题目已经差不多要做完了，但到了算法心态炸了，完完全全看不懂）：
运用c语言中的泡沫排序，确实解决了一道题：
    let len = array.len();
    for i in 0..len {
        for j in 0..len - i - 1 {
            if array[j] > array[j + 1] {
                array.swap(j, j + 1);
            }
        }
    }
每次进行排序会将未进行排序的最大值冒泡至队列的最后，以此类推，未排序的队列的长度会越来越小，直到找出真正的最大值和最小值
说起排序方式，当然不仅仅只有这一种方法，经过查阅大概能掌握的如下：
还有选择排序：（有实例作为支撑）
fn selection_sort<T: std::cmp::PartialOrd>(array: &mut [T]) {
    let len = array.len();
    for i in 0..len {
        let mut min_index = i;
        for j in i + 1..len {
            if array[j] < array[min_index] {
                min_index = j;
            }
        }
        if min_index != i {
            array.swap(i, min_index);
        }
    }
}
选择排序，在为排序的数列中找到最小值，并将最小值与数列首端（也就是i为下标的值）进行交换，这样会从小到大将数列排好顺序。
其实原理大致与冒泡排序相似，只不过每次冒泡寻找的是最大值，选择寻找的是最小值，两个的理解难度大概是相近的。
对插入排序也进行了研究：
将未排序数据插入到已排序序列的合适位置。从第一个元素开始，该元素可以认为已经被排序；取出下一个元素，在已经排序的元素序列中从后向前扫描；如果该元素（已排序）大于新元素，将该元素移到下一位置；重复步骤即可：
fn insertion_sort<T: std::cmp::PartialOrd>(array: &mut [T]) {
    let len = array.len();
    for i in 1..len {
        let mut j = i;
        while j > 0 && array[j - 1] > array[j] {
            array.swap(j - 1, j);
            j -= 1;
        }
    }
}
这个相对理解复杂，相当于每次取已排序队列的下一位的值，逐个与已排序列的值从后往前进行比较，找到合适的位置，实现从小到大的排序。
2.关于BinarySearchTree算法：
这个算法看定义和代码解释看了半天，终于稍微有点了解，说实话算法的题做起来真的很难：
我只能简单的说一下目前我的理解吧（可能有错误，或是理解不到位的地方，希望能多包容）：
在题目中，其与Ordering类型紧密联系，这个枚举类型有三个变体，equal,less,greater,想要插入数据时，让数据与root我认为就是算法中的根数据进行比较，根据该算法左小右大的原则，结合Ordering的返回值，将数据放在何处
而对于查询BST中的节点则是同理，这种算法我基本了解了如何去创建，但我通过想像与查阅，它的作用也不小。




